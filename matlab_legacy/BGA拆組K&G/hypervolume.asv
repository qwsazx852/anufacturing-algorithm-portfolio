% function hv = hypervolume(F)  %(F, AU, U, N)
% Approximates the hypervolume of a Pareto frontier. First, it generates 
% random samples in the hypercuboid defined by the utopia and antiutopia 
% points. Second, it counts the number of samples dominated by the front. 
% The hypervolume is approximated as the ratio 'dominated points / total
% points'.
% Please notice that the choice of the utopia and antiutopia point is
% crucial: using points very far from the frontier will result in similar
% hypervolume even for very different frontiers (if the utopia is too far 
% away, the hypervolume will be always low; if the antiutopia is too far 
% away, the hypervolume will be always high). 
% Also, frontier points "beyond" the reference points will not be counted 
% for the approximation (e.g., if the antiutopia is above the frontier or 
% the utopia is below, the hypervolume will be 0).
% 
% Inputs:
% - F  : the Pareto front to evaluate
% - AU : antiutopia point
% - U  : utopia point
% - N  : number of sample for the approximation
% 
% Outputs:
% - hv : hypervolume
% 生成一個2維的Pareto前沿，包含10個解
% F = rand(10, 2);

% 指定utopia和antiutopia點
% U和AU的設置需要考慮到你的具體問題和目標。一般來說，U應該是最理想的利潤和最小的碳足跡，而AU應該是最小的利潤和最大的碳足跡。你需要根據你的具體情況來設置這些參數。
% 例如，如果你在某個市場上販售產品，你可能希望最大化利潤，同時盡可能減少碳足跡。在這種情況下，你可以將U設置為最大利潤和最小碳足跡，AU設置為最小利潤和最大碳足跡。如果你更關心環境保護，你可能希望將碳足跡視為主要目標，而利潤只是次要目標。在這種情況下，你可以將U設置為最小碳足跡和一個較高但仍可接受的利潤水平，AU設置為一個較高的碳足跡和較低的利潤水平。
% 總之，U和AU的設置應該根據你的具體情況來進行調整。
U = [10000,0.001];
AU = [0,1];
% 設置樣本數量
N = 1000;
%% STAR
F=[216.3824,0.0307]
% 
% function hv = hypervolume(F, AU, U, N)
% 雙目標hypervolume計算函數
% F: 待測的Pareto前緣，是一個n_sol x 2的矩陣，第一列表示利潤，第二列表示碳足跡
% AU: antiutopia點，是一個1 x 2的行向量，表示最不理想的利潤和碳足跡
% U: utopia點，是一個1 x 2的行向量，表示最理想的利潤和碳足跡
% N: 抽樣數量，用於近似計算hypervolume值
[n_sol, dim] = size(F);
samples = [201,0.05]%bsxfun(@plus, AU, bsxfun(@times, (U - AU), rand(N, dim)));
dominated = 0;
for i = 1 : N
    if F(1) >samples(i,1) &  F(2)<samples(i,2)
    dominated = dominated + 1
    end
end
hv = dominated / N;

% [n_sol, dim] = size(F);
% samples = bsxfun( @plus, AU, bsxfun(@times, (U - AU), rand(N, dim)) );
% dominated = 0;
% for i = 1 : n_sol
%     idx = sum( bsxfun( @ge, F(i,:), samples ), 2 ) == dim;
%     dominated = dominated + sum(idx);
%     samples(idx,:) = [];
% end
% hv = dominated / N;
return
